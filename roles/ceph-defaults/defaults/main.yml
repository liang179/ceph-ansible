---
# You can override vars by using host or group vars

###########
# GENERAL #
###########

no_dep: false

# this is only here for usage with the rolling_update.yml playbook
# do not ever change this here
rolling_update: false

fetch_directory: fetch/

mon_group_name: mons
osd_group_name: osds
rgw_group_name: rgws
mds_group_name: mdss
nfs_group_name: nfss
restapi_group_name: restapis
rbdmirror_group_name: rbdmirrors
client_group_name: clients
iscsi_group_name: iscsigws
mgr_group_name: mgrs

# The 'cluster' variable determines the name of the cluster.
# Changing the default value to something else means that you will
# need to change all the command line calls as well, for example if
# your cluster name is 'foo':
# "ceph health" will become "ceph --cluster foo health"
#
# An easier way to handle this is to use the environment variable CEPH_ARGS
# So run: "export CEPH_ARGS="--cluster foo"
# With that you will be able to run "ceph health" normally

cluster: ceph
monitor_secret: "{{ monitor_keyring.stdout }}"
admin_secret: 'admin_secret'
copy_admin_key: false

# CephFS
cephfs_data: cephfs_data
cephfs_metadata: cephfs_metadata
cephfs: cephfs

# Secure your cluster
# This will set the following flags on all the pools:
# * nosizechange
# * nopgchange
# * nodelete

secure_cluster: false
secure_cluster_flags:
  - nopgchange
  - nodelete
  - nosizechange

# Enable the Calamari-backed REST API on a Monitor
calamari: false

# Enable debugging for Calamari
calamari_debug: false

#############
# OPENSTACK #
#############

openstack_config: false
openstack_glance_pool:
  name: images
  pg_num: "{{ osd_pool_default_pg_num }}"
  rule_name: ""
openstack_cinder_pool:
  name: volumes
  pg_num: "{{ osd_pool_default_pg_num }}"
  rule_name: ""
openstack_nova_pool:
  name: vms
  pg_num: "{{ osd_pool_default_pg_num }}"
  rule_name: ""
openstack_cinder_backup_pool:
  name: backups
  pg_num: "{{ osd_pool_default_pg_num }}"
  rule_name: ""
openstack_gnocchi_pool:
  name: metrics
  pg_num: "{{ osd_pool_default_pg_num }}"
  rule_name: ""

openstack_pools:
  - "{{ openstack_glance_pool }}"
  - "{{ openstack_cinder_pool }}"
  - "{{ openstack_nova_pool }}"
  - "{{ openstack_cinder_backup_pool }}"
  - "{{ openstack_gnocchi_pool }}"


# The value for 'key' can be a pre-generated key,
# e.g key: "AQDC2UxZH4yeLhAAgTaZb+4wDUlYOsr1OfZSpQ=="
# By default, keys will be auto-generated.
#
# To have have ansible setfacl the generated key, set the acls var like so:
# acls: ["u:nova:r--", "u:cinder:r--", "u:glance:r--", "u:gnocchi:r--"]
openstack_keys:
  - { name: client.glance, key: "$(ceph-authtool --gen-print-key)", mon_cap: "allow r", osd_cap: "allow class-read object_prefix rbd_children, allow rwx pool={{ openstack_glance_pool.name }}", acls: [] }
  - { name: client.cinder, key: "$(ceph-authtool --gen-print-key)", mon_cap: "allow r", osd_cap: "allow class-read object_prefix rbd_children, allow rwx pool={{ openstack_cinder_pool.name }}, allow rwx pool={{ openstack_nova_pool.name }}, allow rx pool={{ openstack_glance_pool.name }}", acls: []  }
  - { name: client.cinder-backup, key: "$(ceph-authtool --gen-print-key)", mon_cap: "allow r", osd_cap: "allow class-read object_prefix rbd_children, allow rwx pool={{ openstack_cinder_backup_pool.name }}", acls: [] }
  - { name: client.gnocchi, key: "$(ceph-authtool --gen-print-key)", mon_cap: "allow r", osd_cap: "allow class-read object_prefix rbd_children, allow rwx pool={{ openstack_gnocchi_pool.name }}", acls: [] }
  - { name: client.openstack, key: "$(ceph-authtool --gen-print-key)", mon_cap: "allow r", osd_cap: "allow class-read object_prefix rbd_children, allow rwx pool=images, allow rwx pool=vms, allow rwx pool=volumes, allow rwx pool=backups", acls: [] }

#############
# crush rules
#############
crush_rule_config: false

crush_rule_hdd:
  name: HDD
  root: HDD
  type: rack
  default: true

crush_rule_ssd:
  name: SSD
  root: SSD
  type: host
  default: false

crush_rules:
  - "{{ crush_rule_hdd }}"
  - "{{ crush_rule_ssd }}"


####################
# OSD CRUSH LOCATION
####################

# /!\
#
# BE EXTREMELY CAREFUL WITH THIS OPTION
# DO NOT USE IT UNLESS YOU KNOW WHAT YOU ARE DOING
#
# /!\
#
# It is probably best to keep this option to 'false' as the default
# suggests it. This option should only be used while doing some complex
# CRUSH map. It allows you to force a specific location for a set of OSDs.
#
# The following options will build a ceph.conf with OSD sections
# Example:
# [osd.X]
# osd crush location = "root=location"
#
# This works with your inventory file
# To match the following 'osd_crush_location' option the inventory must look like:
#
# [osds]
# osd0 ceph_crush_root=foo ceph_crush_rack=bar

crush_location: false
osd_crush_location: "\"root={{ ceph_crush_root }} rack={{ ceph_crush_rack }} host={{ ansible_hostname }}\""


###############
# OSD OPTIONS #
###############

# Devices to be used as OSDs
# You can pre-provision disks that are not present yet.
# Ansible will just skip them. Newly added disk will be
# automatically configured during the next run.
#


# Declare devices to be used as OSDs
# All scenario(except 3rd) inherit from the following device declaration

#devices:
#  - /dev/sdb
#  - /dev/sdc
#  - /dev/sdd
#  - /dev/sde

devices: []


#'osd_auto_discovery'  mode prevents you from filling out the 'devices' variable above.
#  You can use this option with First and Forth and Fifth OSDS scenario.
# Device discovery is based on the Ansible fact 'ansible_devices'
# which reports all the devices on a system. If chosen all the disks
# found will be passed to ceph-disk. You should not be worried on using
# this option since ceph-disk has a built-in check which looks for empty devices.
# Thus devices with existing partition tables will not be used.
#
osd_auto_discovery: false


# !! WARNING !!
# #
# # /!\ ENABLE ONLY ONE SCENARIO AT A TIME /!\
# #
# #  !! WARNING !!
#

# I. First scenario: journal and osd_data on the same device
# Use 'true' to enable this scenario
# This will collocate both journal and data on the same disk
# creating a partition at the beginning of the device
# List devices under 'devices' variable above or choose 'osd_auto_discovery'
#
#
# If osd_objectstore: bluestore is enabled both rocksdb DB and WAL will be stored
# on the device. So the device will get 2 partitions:
# - One for 'data', also called 'block'
# - One for block, db, and wal data
#
# Example of what you will get:
# [root@ceph-osd0 ~]# blkid /dev/sda*
# /dev/sda: PTTYPE="gpt"
# /dev/sda1: UUID="9c43e346-dd6e-431f-92d8-cbed4ccb25f6" TYPE="xfs" PARTLABEL="ceph data" PARTUUID="749c71c9-ed8f-4930-82a7-a48a3bcdb1c7"
# /dev/sda2: PARTLABEL="ceph block" PARTUUID="e6ca3e1d-4702-4569-abfa-e285de328e9d"
journal_collocation: false


# II.  Second scenario:  N journal devices for N OSDs
# Use 'true' for 'raw_multi_journal' to enable this scenario
# List devices under 'devices' variable above and
# write journal devices for those under 'raw_journal_devices'
# In the following example:
# * sdb and sdc will get sdf as a journal
# * sdd and sde will get sdg as a journal

# While starting you have 2 options:
# 1. Pre-allocate all the devices
# 2. Progressively add new devices
raw_multi_journal: false
#raw_journal_devices:
#  - /dev/sdf
#  - /dev/sdf
#  - /dev/sdg
#  - /dev/sdg
#
# NOTE(leseb):
# On a containerized scenario we only support A SINGLE journal
# for all the OSDs on a given machine. If you don't, bad things will happen
# This is a limitation we plan to fix at some point.
#
#
# If osd_objectstore: bluestore is enabled, both rocksdb DB and WAL will be stored
# on a dedicated device. So the following will happen:
# - The devices listed in 'devices' will get 2 partitions, one for 'block' and one for 'data'.
# 'data' is only 100MB big and do not store any of your data, it's just a bunch of Ceph metadata.
# 'block' will store all your data.
# - The devices in 'raw_journal_devices' will get 1 partition for RocksDB DB, called 'block.db'
#  and one for RocksDB WAL, called 'block.wal'
#
# By default raw_journal_devices will represent block.db
#
# Example of what you will get:
# [root@ceph-osd0 ~]# blkid /dev/sd*
# /dev/sda: PTTYPE="gpt"
# /dev/sda1: UUID="c6821801-2f21-4980-add0-b7fc8bd424d5" TYPE="xfs" PARTLABEL="ceph data" PARTUUID="f2cc6fa8-5b41-4428-8d3f-6187453464d0"
# /dev/sda2: PARTLABEL="ceph block" PARTUUID="ea454807-983a-4cf2-899e-b2680643bc1c"
# /dev/sdb: PTTYPE="gpt"
# /dev/sdb1: PARTLABEL="ceph block.db" PARTUUID="af5b2d74-4c08-42cf-be57-7248c739e217"
# /dev/sdb2: PARTLABEL="ceph block.wal" PARTUUID="af3f8327-9aa9-4c2b-a497-cf0fe96d126a"
raw_journal_devices: []


# IV. This will partition disks for BlueStore
# To enable bluestore just set:
# osd_objectstore: bluestore
#
# If osd_objectstore: bluestore is enabled.
# By default, if bluestore_wal_devices is empty, it will get the content of raw_journal_devices.
# If set, then you will have a dedicated partition on a specific device (bluestore_wal_devices)
# for block.wal
#
# Example of what you will get:
# [root@ceph-osd0 ~]# blkid /dev/sd*
# /dev/sda: PTTYPE="gpt"
# /dev/sda1: UUID="39241ae9-d119-4335-96b3-0898da8f45ce" TYPE="xfs" PARTLABEL="ceph data" PARTUUID="961e7313-bdb7-49e7-9ae7-077d65c4c669"
# /dev/sda2: PARTLABEL="ceph block" PARTUUID="bff8e54e-b780-4ece-aa16-3b2f2b8eb699"
# /dev/sdb: PTTYPE="gpt"
# /dev/sdb1: PARTLABEL="ceph block.db" PARTUUID="0734f6b6-cc94-49e9-93de-ba7e1d5b79e3"
# /dev/sdc: PTTYPE="gpt"
# /dev/sdc1: PARTLABEL="ceph block.wal" PARTUUID="824b84ba-6777-4272-bbbd-bfe2a25cecf3"
bluestore_wal_devices: "{{ raw_journal_devices }}"


# V. Encrypt osd data and/or journal devices with dm-crypt.
# Keys are stored into the monitors k/v store
# Use 'true' to enable this scenario
# Both journal and data are stored on the same dm-crypt encrypted device
dmcrypt_journal_collocation: false


# VI. Encrypt osd data and/or journal devices with dm-crypt.
# Keys are stored into the monitors k/v store
# Use 'true' to enable this scenario
# Journal and osd data are separated, each with their own dm-crypt device
# You must use raw_journal_devices and set your journal devices
dmcrypt_dedicated_journal: false


###########
# INSTALL #
###########

bootstrap_dirs_owner: "64045"
bootstrap_dirs_group: "64045"

# If check_firewall is true, then ansible will try to determine if the
# Ceph ports are blocked by a firewall. If the machine running ansible
# cannot reach the Ceph ports for some other reason, you may need or
# want to set this to False to skip those checks.
check_firewall: False

# This variable determines if ceph packages can be updated.  If False, the
# package resources will use "state=present".  If True, they will use
# "state=latest".
upgrade_ceph_packages: False

# /!\ EITHER ACTIVE ceph_stable OR ceph_stable_uca OR ceph_dev OR ceph_custom /!\

debian_package_dependencies:
  - python-pycurl
  - hdparm

centos_package_dependencies:
  - python-pycurl
  - hdparm
  - epel-release
  - python-setuptools
  - libselinux-python

redhat_package_dependencies:
  - python-pycurl
  - hdparm
  - python-setuptools

# Enable the ntp service by default to avoid clock skew on
# ceph nodes
ntp_service_enabled: true

# Whether or not to install the ceph-test package.
ceph_test: False

## Configure package origin
#
ceph_origin: 'upstream' # or 'distro' or 'local'
# 'distro' means that no separate repo file will be added
# you will get whatever version of Ceph is included in your Linux distro.
# 'local' means that the ceph binaries will be copied over from the local machine

# LOCAL CEPH INSTALLATION (ceph_origin==local)
#
# Path to DESTDIR of the ceph install
#ceph_installation_dir: "/path/to/ceph_installation/"
# Whether or not to use installer script rundep_installer.sh
# This script takes in rundep and installs the packages line by line onto the machine
# If this is set to false then it is assumed that the machine ceph is being copied onto will already have
# all runtime dependencies installed
#use_installer: false
# Root directory for ceph-ansible
#ansible_dir: "/path/to/ceph-ansible"

ceph_use_distro_backports: false # DEBIAN ONLY

# STABLE
########

# COMMUNITY VERSION
ceph_stable: false # use ceph stable branch
ceph_mirror: http://download.ceph.com
ceph_stable_key: https://download.ceph.com/keys/release.asc
ceph_stable_release: kraken # ceph stable release
ceph_stable_repo: "{{ ceph_mirror }}/debian-{{ ceph_stable_release }}"

######################################
# Releases name to number dictionary #
######################################
ceph_release_num:
  dumpling: 0.67
  emperor: 0.72
  firefly: 0.80
  giant: 0.87
  hammer: 0.94
  infernalis: 9
  jewel: 10
  kraken: 11
  luminous: 12

# Use the option below to specify your applicable package tree, eg. when using non-LTS Ubuntu versions
# # for a list of available Debian distributions, visit http://download.ceph.com/debian-{{ ceph_stable_release }}/dists/
# for more info read: https://github.com/ceph/ceph-ansible/issues/305
#ceph_stable_distro_source:

# This option is needed for _both_ stable and dev version, so please always fill the right version
# # for supported distros, see http://download.ceph.com/rpm-{{ ceph_stable_release }}/
ceph_stable_redhat_distro: el7

# ENTERPRISE VERSION RED HAT STORAGE (from 1.3)
# This version is only supported on RHEL >= 7.1
# As of RHEL 7.1, libceph.ko and rbd.ko are now included in Red Hat's kernel
# packages natively. The RHEL 7.1 kernel packages are more stable and secure than
# using these 3rd-party kmods with RHEL 7.0. Please update your systems to RHEL
# 7.1 or later if you want to use the kernel RBD client.
#
# The CephFS kernel client is undergoing rapid development upstream, and we do
# not recommend running the CephFS kernel module on RHEL 7's 3.10 kernel at this
# time. Please use ELRepo's latest upstream 4.x kernels if you want to run CephFS
# on RHEL 7.
#
#
# Backward compatibility of variable names
# Commit 492518a2 changed variable names of rhcs installations
# to not break backward compatiblity we re-declare these variables
# with the content of the new variable
ceph_rhcs: "{{ ceph_stable_rh_storage | default(false) }}"
# This will affect how/what repositories are enabled depending on the desired
# version. The previous version was 1.3. The current version is 2.
ceph_rhcs_version: "{{ ceph_stable_rh_storage_version | default(2) }}"
ceph_rhcs_cdn_install: "{{ ceph_stable_rh_storage_cdn_install | default(false) }}" # assumes all the nodes can connect to cdn.redhat.com
ceph_rhcs_iso_install: "{{ ceph_stable_rh_storage_iso_install | default(false) }}" # usually used when nodes don't have access to cdn.redhat.com
ceph_rhcs_iso_path: "{{ ceph_stable_rh_storage_iso_path | default('') }}"
ceph_rhcs_mount_path: "{{ ceph_stable_rh_storage_mount_path | default('/tmp/rh-storage-mount') }}"
ceph_rhcs_repository_path: "{{ ceph_stable_rh_storage_repository_path | default('/tmp/rh-storage-repo') }}" # where to copy iso's content


# UBUNTU CLOUD ARCHIVE
# This allows the install of Ceph from the Ubuntu Cloud Archive.  The Ubuntu Cloud Archive
# usually has newer Ceph releases than the normal distro repository.
#
ceph_stable_uca: false
#ceph_stable_repo_uca: "http://ubuntu-cloud.archive.canonical.com/ubuntu"
#ceph_stable_openstack_release_uca: liberty
#ceph_stable_release_uca: "{{ansible_lsb.codename}}-updates/{{ceph_stable_openstack_release_uca}}"

# DEV
# ###

ceph_dev: false # use ceph development branch
ceph_dev_branch: master # development branch you would like to use e.g: master, wip-hack
ceph_dev_sha1: latest # distinct sha1 to use, defaults to 'latest' (as in latest built)

# CUSTOM
# ###

# Use a custom repository to install ceph.  For RPM, ceph_custom_repo should be
# a URL to the .repo file to be installed on the targets.  For deb,
# ceph_custom_repo should be the URL to the repo base.
ceph_custom: false # use custom ceph repository
ceph_custom_repo: https://server.domain.com/ceph-custom-repo


######################
# CEPH CONFIGURATION #
######################

## Ceph options
#
# Each cluster requires a unique, consistent filesystem ID. By
# default, the playbook generates one for you and stores it in a file
# in `fetch_directory`. If you want to customize how the fsid is
# generated, you may find it useful to disable fsid generation to
# avoid cluttering up your ansible repo. If you set `generate_fsid` to
# false, you *must* generate `fsid` in another way.
fsid: "{{ cluster_uuid.stdout }}"
generate_fsid: true

cephx: true
max_open_files: 131072

## Client options
#
rbd_cache: "true"
rbd_cache_writethrough_until_flush: "true"
rbd_concurrent_management_ops: 20

rbd_client_directories: true # this will create rbd_client_log_path and rbd_client_admin_socket_path directories with proper permissions

# Permissions for the rbd_client_log_path and
# rbd_client_admin_socket_path. Depending on your use case for Ceph
# you may want to change these values. The default, which is used if
# any of the variables are unset or set to a false value (like `null`
# or `false`) is to automatically determine what is appropriate for
# the Ceph version with non-OpenStack workloads -- ceph:ceph and 0770
# for infernalis releases, and root:root and 1777 for pre-infernalis
# releases.
#
# For other use cases, including running Ceph with OpenStack, you'll
# want to set these differently:
#
# For OpenStack on RHEL, you'll want:
#   rbd_client_directory_owner: "qemu"
#   rbd_client_directory_group: "libvirtd" (or "libvirt", depending on your version of libvirt)
#   rbd_client_directory_mode: "0755"
#
# For OpenStack on Ubuntu or Debian, set:
#    rbd_client_directory_owner: "libvirt-qemu"
#    rbd_client_directory_group: "kvm"
#    rbd_client_directory_mode: "0755"
#
# If you set rbd_client_directory_mode, you must use a string (e.g.,
# 'rbd_client_directory_mode: "0755"', *not*
# 'rbd_client_directory_mode: 0755', or Ansible will complain: mode
# must be in octal or symbolic form
rbd_client_directory_owner: null
rbd_client_directory_group: null
rbd_client_directory_mode: null

rbd_client_log_path: /var/log/ceph
rbd_client_log_file: "{{ rbd_client_log_path }}/qemu-guest-$pid.log" # must be writable by QEMU and allowed by SELinux or AppArmor
rbd_client_admin_socket_path: /var/run/ceph # must be writable by QEMU and allowed by SELinux or AppArmor

## Monitor options
#
# You must define either monitor_interface, monitor_address or monitor_address_block.
# These variables must be defined at least in all.yml and overrided if needed (inventory host file or group_vars/*.yml).
# Eg. If you want to specify for each monitor which address the monitor will bind to you can set it in your **inventory host file** by using 'monitor_address' variable.
# Preference will go to monitor_address if both monitor_address and monitor_interface are defined.
# To use an IPv6 address, use the monitor_address setting instead (and set ip_version to ipv6)
monitor_interface: interface
monitor_address: 0.0.0.0
monitor_address_block: []
# set to either ipv4 or ipv6, whichever your network is using
ip_version: ipv4
mon_use_fqdn: false # if set to true, the MON name used will be the fqdn in the ceph.conf

## OSD options
#
journal_size: 5120 # OSD journal size in MB
public_network: 0.0.0.0/0
cluster_network: "{{ public_network }}"
osd_mkfs_type: xfs
osd_mkfs_options_xfs: -f -i size=2048
osd_mount_options_xfs: noatime,largeio,inode64,swalloc
osd_objectstore: filestore

# xattrs. by default, 'filestore xattr use omap' is set to 'true' if
# 'osd_mkfs_type' is set to 'ext4'; otherwise it isn't set. This can
# be set to 'true' or 'false' to explicitly override those
# defaults. Leave it 'null' to use the default for your chosen mkfs
# type.
filestore_xattr_use_omap: null

## MDS options
#
mds_use_fqdn: false # if set to true, the MDS name used will be the fqdn in the ceph.conf
mds_allow_multimds: false
mds_max_mds: 3

##########################
#  Rados Gateway options #
##########################
#radosgw_dns_name: your.subdomain.tld # subdomains used by radosgw. See http://ceph.com/docs/master/radosgw/config/#enabling-subdomain-s3-calls
radosgw_resolve_cname: false # enable for radosgw to resolve DNS CNAME based bucket names
radosgw_civetweb_port: 8080
radosgw_civetweb_bind_ip: "{{ ansible_default_ipv4.address }}" # when using ipv6 enclose with brackets: "[{{ ansible_default_ipv6.address }}]"
radosgw_civetweb_num_threads: 100
# For additional civetweb configuration options available such as SSL, logging,
# keepalive, and timeout settings, please see the civetweb docs at
# https://github.com/civetweb/civetweb/blob/master/docs/UserManual.md
radosgw_civetweb_options: "port={{ radosgw_civetweb_bind_ip }}:{{ radosgw_civetweb_port }} num_threads={{ radosgw_civetweb_num_threads }}"
radosgw_keystone: false # activate OpenStack Keystone options full detail here: http://ceph.com/docs/master/radosgw/keystone/
#radosgw_keystone_url: # url:admin_port ie: http://192.168.0.1:35357
radosgw_keystone_api_version: 2 # API versions 2 and 3 are supported
radosgw_keystone_ssl: true # Can be used to disable PKI revocation checks when other token types are used.
# for admin_token method, define radosgw_keystone_admin_token
# for auth_token method, define _user, _password, and _tenant
radosgw_keystone_auth_method: admin_token
radosgw_keystone_admin_token: password
radosgw_keystone_admin_user: username
radosgw_keystone_admin_password: password
radosgw_keystone_admin_tenant: tenant
radosgw_keystone_admin_domain: default
radosgw_keystone_accepted_roles: Member, _member_, admin
radosgw_keystone_token_cache_size: 10000
radosgw_keystone_revocation_internal: 900
radosgw_s3_auth_use_keystone: "true"
radosgw_nss_db_path: /var/lib/ceph/radosgw/ceph-radosgw.{{ ansible_hostname }}/nss
# Settings for the RGW usage logging described at http://docs.ceph.com/docs/jewel/man/8/radosgw/#usage-logging
radosgw_usage_log: false
radosgw_usage_log_tick_interval: 30
radosgw_usage_log_flush_threshold: 1024
radosgw_usage_max_shards: 32
radosgw_usage_max_user_shards: 1
# Settings for static website hosting
radosgw_static_website: false
radosgw_dns_s3website_name: your.subdomain.tld # subdomain used by radosgw for website bucket hosting.
# Rados Gateway options
email_address: foo@bar.com

####################
# REST API options #
####################
restapi_interface: "{{ monitor_interface }}"
restapi_address: "{{ monitor_address }}"
restapi_port: 5000


########################
#   RBD_MIRROR options #
########################
# NOTE (leseb): the rbd-mirror daemon needs a user to start
# because it has to authenticate with the local cluster.
# By default, using the admin user is fine, so you should not
# need to change 'ceph_rbd_mirror_local_user' unless you have
# a dedicated key available in /etc/ceph/.
# Generally Ansible will use the admin key and put it
# under /etc/ceph/. The same goes for 'ceph_rbd_mirror_remote_user'
# there should not be any reason to change it.
ceph_rbd_mirror_local_user: admin
ceph_rbd_mirror_remote_user: admin

# NOTE (leseb): the following variable needs the name of the remote cluster.
# The name of this cluster must be different than your local cluster simply
# because we need to have both keys and ceph.conf inside /etc/ceph.
# Thus if cluster names are identical we can not have them under /etc/ceph
ceph_rbd_mirror_remote_cluster: ""


############################
# RBD_MIRROR CONFIGURATION #
############################
ceph_rbd_mirror_configure: false
ceph_rbd_mirror_pool: ""




## Testing mode
# enable this mode _only_ when you have a single node
# if you don't want it keep the option commented
#common_single_host_mode: true

## Handlers - restarting daemons after a config change
# if for whatever reasons the content of your ceph configuration changes
# ceph daemons will be restarted as well. At the moment, we can not detect
# which config option changed so all the daemons will be restarted. Although
# this restart will be serialized for each node, in between a health check
# will be performed so we make sure we don't move to the next node until
# ceph is not healthy
# Obviously between the checks (for monitors to be in quorum and for osd's pgs
# to be clean) we have to wait. These retries and delays can be configurable
# for both monitors and osds.
handler_health_mon_check_retries: 5
handler_health_mon_check_delay: 10
handler_health_osd_check_retries: 40
handler_health_osd_check_delay: 30
handler_health_osd_check: true

###################
# CONFIG OVERRIDE #
###################

# Ceph configuration file override.
# This allows you to specify more configuration options
# using an INI style format.
# The following sections are supported: [global], [mon], [osd], [mds], [rgw]
#
# Example:
# ceph_conf_overrides:
#   global:
#     foo: 1234
#     bar: 5678
#
ceph_conf_overrides: {}

###### NFS
# Confiure the type of NFS gatway access.  At least one must be enabled for an
# NFS role to be useful
#
# Set this to true to enable File access via NFS.  Requires an MDS role.
nfs_file_gw: true
# Set this to true to enable Object access via NFS. Requires an RGW role.
nfs_obj_gw: false

#######################
# Access type options #
#######################
# These are currently in ceph-common defaults because nfs_obj_gw shared with ceph-rgw
# Enable NFS File access
#nfs_file_gw: true
# Enable NFS Object access
#nfs_obj_gw: false

######################
# NFS Ganesha Config #
######################
ceph_nfs_export_id: 20134
ceph_nfs_pseudo_path: "/cephfile"
ceph_nfs_protocols: "3,4"
ceph_nfs_access_type: "RW"
ceph_nfs_log_file: "/var/log/ganesha.log"

####################
# FSAL Ceph Config #
####################
ceph_nfs_ceph_export_id: 20134
ceph_nfs_ceph_pseudo_path: "/cephobject"
ceph_nfs_ceph_protocols: "3,4"
ceph_nfs_ceph_access_type: "RW"

###################
# FSAL RGW Config #
###################
ceph_nfs_rgw_export_id: 20134
ceph_nfs_rgw_pseudo_path: "/ceph"
ceph_nfs_rgw_protocols: "3,4"
ceph_nfs_rgw_access_type: "RW"
ceph_nfs_rgw_user: "cephnfs"
# Note: keys are optional and can be generated, but not on containerized, where
# they must be configered.
#ceph_nfs_rgw_access_key: "QFAMEDSJP5DEKJO0DDXY"
#ceph_nfs_rgw_secret_key: "iaSFLDVvDdQt6lkNzHyW4fPLZugBAI1g17LO0+87[MAC[M#C"

#### RGW
# Multi-site remote pull URL variables
rgw_pull_port: "{{ radosgw_civetweb_port }}"
rgw_pull_proto: "http"

## RGW tunning
# To support buckets with a very large number of objects it's 
# important to split them into shards. We suggest about 100K
# objects per shard as a conservative maximum.
#rgw_override_bucket_index_max_shards: 16
 
# Consider setting a quota on buckets so that exceeding this
# limit will require admin intervention.
#rgw_bucket_default_quota_max_objects: 1638400 # i.e., 100K * 16

# This dictionary will create pools with the given number of pgs. 
# This is important because they would be created with the default
# of 8. 
# New pools and their corresponding pg_nums can be created
# by adding to the create_pools dictionary (see foo).
#create_pools:
#  defaults.rgw.buckets.data:
#    pg_num: 16
#  defaults.rgw.buckets.index:
#    pg_num: 32
#  foo:
#    pg_num: 4

#############
# OS TUNING #
#############

disable_transparent_hugepage: true
os_tuning_params:
  - { name: kernel.pid_max, value: 4194303 }
  - { name: fs.file-max, value: 26234859 }
  - { name: vm.zone_reclaim_mode, value: 0 }
  - { name: vm.swappiness, value: 10 }
  - { name: vm.min_free_kbytes, value: "{{ vm_min_free_kbytes }}" }


##############
# CEPH-AGENT #
##############

# The agent needs an agent_master_host variable defined so that it can connect
# and push information back to it
agent_master_host: "localhost"


###############
# CEPH-CLIENT #
###############

user_config: false
pools:
  - { name: test, pgs: "{{ ceph_conf_overrides.global.osd_pool_default_pg_num }}" }
  - { name: test2, pgs: "{{ ceph_conf_overrides.global.osd_pool_default_pg_num }}" }

# Can add `mds_cap` attribute to override the default value which is '' for mds capabilities.
# To have have ansible setfacl the generated key for $user, set the acls var like so:
# acls: ["u:$user:r--"]
keys:
  - { name: client.test, key: "$(ceph-authtool --gen-print-key)", mon_cap: "allow r", osd_cap: "allow class-read object_prefix rbd_children, allow rwx pool=test", acls: [] }
  - { name: client.test2, key: "$(ceph-authtool --gen-print-key)", mon_cap: "allow r", osd_cap: "allow class-read object_prefix rbd_children, allow rwx pool=test2", acls: [] }


##########
# DOCKER #
##########
#
###### COMMON
docker: false
docker_exec_cmd:
ceph_docker_image: "ceph/daemon"
ceph_docker_image_tag: latest

ceph_docker_registry: docker.io
ceph_docker_enable_centos_extra_repo: false
ceph_docker_on_openstack: false
ceph_conf_key_directory: /etc/ceph
kv_type: etcd
kv_endpoint: 127.0.0.1
kv_port: 2379

# Do not comment the following variables containerized_deployment_* here. These variables are being used
# by ceph.conf.j2 template. so it should always be defined
containerized_deployment_with_kv: false
containerized_deployment: false

###### MON
mon_containerized_default_ceph_conf_with_kv: false
ceph_mon_docker_subnet: "{{ public_network }}"# subnet of the monitor_interface
# ceph_mon_docker_extra_env:
#
# Use this variable to add extra env configuration to run your mon container.
# If you want to set a custom admin keyring you can set this variable like following:
# ceph_mon_docker_extra_env: -e CLUSTER={{ cluster }} -e FSID={{ fsid }} -e MON_NAME={{ monitor_name }} -e ADMIN_SECRET={{ admin_secret }}
ceph_mon_docker_extra_env: -e CLUSTER={{ cluster }} -e FSID={{ fsid }} -e MON_NAME={{ monitor_name }}
mon_docker_privileged: false
mon_docker_net_host: true



###### OSD
#
# PREPARE DEVICE
# Make sure you only pass a single device to raw_journal_devices, otherwise this will fail horribly.
# This is why we use [0] in the example.
#
# WARNING /!\ DMCRYPT scenario ONLY works with Docker version 1.12.5 and above
#
# Examples:
# Journal collocated on Filestore: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FORCE_ZAP=1 -e OSD_FILESTORE=1
# Dedicated journal on Filestore: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FORCE_ZAP=1 -e OSD_JOURNAL={{ raw_journal_devices[0] }} -e OSD_FILESTORE=1
# Encrypted OSD on Filestore: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FORCE_ZAP=1 -e OSD_DMCRYPT=1 -e OSD_FILESTORE=1
# Encrypted OSD with dedicated journal on Filestore: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FORCE_ZAP=1 -e OSD_DMCRYPT=1 -e OSD_JOURNAL={{ raw_journal_devices[0] }} -e OSD_FILESTORE=1
#
# Bluestore OSD collocated: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_BLUESTORE=1
# Bluestore OSD with dedicated db: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_BLUESTORE=1 -e OSD_JOURNAL={{ raw_journal_devices[0] }}
# Bluestore OSD with dedicated db and wal: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_BLUESTORE=1 -e OSD_JOURNAL={{ raw_journal_devices[0] }} -e OSD_BLUESTORE_BLOCK_WAL={{ bluestore_wal_devices[0] }}
# Encrypted OSD: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FORCE_ZAP=1 -e OSD_DMCRYPT=1 -e OSD_FILESTORE=1
# Encrypted OSD with dedicated journal: ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FORCE_ZAP=1 -e OSD_DMCRYPT=1 -e OSD_JOURNAL={{ raw_journal_devices[0] }} -e OSD_FILESTORE=1
#
#
ceph_osd_docker_devices: "{{ devices }}"
ceph_osd_docker_prepare_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FORCE_ZAP=1

# ACTIVATE DEVICE
# Examples:
# Journal collocated or Dedicated journal on Filesore: ceph_osd_docker_extra_env: -e CLUSTER={{ cluster }} -e CEPH_DAEMON=OSD_CEPH_DISK_ACTIVATE -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_FILESTORE=1
# Encrypted OSD or Encrypted OSD with dedicated journal: ceph_osd_docker_extra_env: -e CLUSTER={{ cluster }} -e CEPH_DAEMON=OSD_CEPH_DISK_ACTIVATE -e OSD_JOURNAL_SIZE={{ journal_size }} -e OSD_DMCRYPT=1 -e OSD_FILESTORE=1
# Bluestore OSD: ceph_osd_docker_extra_env: -e CLUSTER={{ cluster }} -e CEPH_DAEMON=OSD_CEPH_DISK_ACTIVATE -e OSD_BLUESTORE=1
#
ceph_osd_docker_extra_env: -e CLUSTER={{ cluster }} -e OSD_JOURNAL_SIZE={{ journal_size }}
ceph_osd_docker_run_script_path: "/usr/share" # script called by systemd to run the docker command

###### MDS
ceph_mds_docker_extra_env: -e CLUSTER={{ cluster }} -e MDS_NAME={{ ansible_hostname }}
###### MGR
ceph_mgr_docker_extra_env: -e CLUSTER={{ cluster }} -e MGR_NAME={{ ansible_hostname }}
###### RESTAPI
ceph_restapi_docker_interface: eth0
ceph_restapi_port: 5000
ceph_restapi_docker_extra_env: "RESTAPI_IP=0.0.0.0" # comma separated variables
###### RGW
ceph_rgw_civetweb_port: "{{ radosgw_civetweb_port }}"
ceph_rgw_docker_extra_env: -e CLUSTER={{ cluster }} -e RGW_CIVETWEB_PORT={{ ceph_rgw_civetweb_port }}
rgw_config_keys: "/" # DON'T TOUCH ME


##############
# DOCKER-NFS #
##############
#NOTE: (guits) to check
ceph_docker_image_ganesha: "ceph/ganesha"
ceph_docker_image_tag_ganesha: latest
#ceph_nfs_docker_extra_env: -e GANESHA_EPOCH={{ ganesha_epoch }}
ceph_config_keys: [] # DON'T TOUCH ME
